/**
 *    Copyright 2009-2018 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.executor.statement;

import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;

import java.sql.*;
import java.util.List;

/**
 * @author Clinton Begin
 */
public class PreparedStatementHandler extends BaseStatementHandler {

  public PreparedStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    super(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);
  }

  // å¯¹Statementæ‰§è¡Œæ›´æ–°æ“ä½œ
  @Override
  public int update(Statement statement) throws SQLException {
    // ğŸ‡«ğŸ‡¯ğŸ‡«ğŸ‡¯ğŸ‡«ğŸ‡¯ å»ºè®®debug -- çœ‹çœ‹StateHandlerçš„å¤„ç†è¿‡ç¨‹å“¦

    // 1. å¼ºè½¬åè¿›è¡Œæ‰§è¡ŒStatement
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute(); // -- ä¼šè¿æ¥æ•°æ®åº“ç„¶åæ‰§è¡Œå¯¹åº”çš„é¢sql -- PreparedStatementçš„å ä½ç¬¦å¡«å……å·²ç»åœ¨
    // 2. è·å–æ‰§è¡Œåçš„ç»“æœ rowCount
    int rows = ps.getUpdateCount();
    // 3. ä»boundSqlè·å–å½¢å‚å¯¹è±¡ -- ä¸»è¦æ˜¯ KeyGenerator.processAfter() å¯èƒ½ä¼šå‘ parameterObject å›å¡«æ•°æ®
    Object parameterObject = boundSql.getParameterObject();
    // 4. æ‰§è¡Œå®Œåéœ€è¦æŒ‡å®š mappedStatement.getKeyGenerator().processAfter()
    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
    // ä¼ å…¥çš„å¯¹è±¡ -- æ‰§è¡Œå™¨executor\DMLæ ‡ç­¾çš„mappedStatement\æ‰§è¡Œçš„PreparedStatement\ä¼ å…¥çš„å½¢å‚parameterObject
    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);
    return rows;
  }

  @Override
  public void batch(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.addBatch();
  }

  @Override
  public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {
    // å¼€å§‹æ‰§è¡Œsqlçš„æŸ¥è¯¢
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    // æŸ¥è¯¢è¯­å¥çš„ç»“æœä¼šä½¿ç”¨resultSetHandlerå°†ç»“æœå›å¡«è¿›å»
    return resultSetHandler.handleResultSets(ps);
  }

  @Override
  public <E> Cursor<E> queryCursor(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    return resultSetHandler.handleCursorResultSets(ps);
  }

  @Override
  protected Statement instantiateStatement(Connection connection) throws SQLException {
    // è·å–æ‰§è¡Œçš„åŠ¨æ€çš„sql

    String sql = boundSql.getSql();
    // mappedStatement.getKeyGenerator() ä¸‰ç§æƒ…å†µ
    // 1. å¼€å¯å…¨å±€é…ç½®,å¹¶ä¸”å±€éƒ¨é…ç½®å¼€å¯useGeneratorKey -- å°±æ˜¯Jdbc3KeyGenerator
    // 2. æ²¡æœ‰å¼€å¯å…¨å±€é…ç½® -- å°±æ˜¯NoKeyGenerator
    // 3. DMLæ ‡ç­¾ä¸­æœ‰<SelectKey>æ ‡ç­¾
    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {
      String[] keyColumnNames = mappedStatement.getKeyColumns();
      if (keyColumnNames == null) {
        //  å½“æˆ‘ä»¬å†³å®šé…ç½®insert/updateä¸­çš„useGeneratedKeyså±æ€§çš„å€¼ä¸ºtrue,ä»¥æ­¤æ¥è·å–æ•°æ®åº“ç”Ÿæˆçš„ä¸»é”®æ—¶,æˆ‘ä»¬å°±éœ€è¦ç€æ‰‹é…ç½®keyPropertyå±æ€§å’ŒkeyColumnå±æ€§äº†.
        //  keyPropertyå±æ€§çš„å–å€¼æ˜¯javaå¯¹è±¡çš„å±æ€§å,å½“è·å–åˆ°æ–°å¢æ•°æ®è®°å½•çš„ä¸»é”®ä¹‹å,mybatisä¼šå°†ä¸»é”®å¯¹åº”çš„å€¼èµ‹ç»™keyPropertyæŒ‡å‘çš„å±æ€§,å¦‚æœæœ‰å¤šä¸ªå±æ€§,å¯ä»¥ä½¿ç”¨,è¿›è¡Œåˆ†éš”.
        //  keyColumnå±æ€§ç¨æœ‰ä¸åŒ,ä»–åªåœ¨statementTypeå±æ€§ä¸ºPREPAREDæ—¶æ‰ä¼šç”Ÿæ•ˆ.
        //  keyColumnå±æ€§ç”¨äºæŒ‡å®šå½“Statementæ‰§è¡Œå®Œæˆå,éœ€è¦è¿”å›çš„æ•°æ®çš„æ•°æ®åˆ—åç§°,å¦‚æœæœ‰å¤šä¸ªæ•°æ®åˆ—çš„è¯,å¯ä»¥ä½¿ç”¨,è¿›è¡Œåˆ†éš”.
        //  å‰é¢æˆ‘ä»¬å·²ç»è¯´è¿‡äº†statementTypeå±æ€§ç”¨äºæ§åˆ¶Statementå®ä¾‹çš„ç±»å‹,å…¶ä¸­PREPAREDå¯¹åº”çš„æ˜¯PreparedStatement.
        //  åœ¨JDBCä¸­,Connectioné€šè¿‡prepareStatement()æ–¹æ³•æ¥åˆ›å»ºPreparedStatementå¯¹è±¡.
        //  prepareStatement()æ–¹æ³•æœ‰å¤šç§é‡è½½å®ç°,æˆ‘ä»¬è¿™é‡Œä¸»è¦çœ‹ä¸‹é¢ä¸¤ç§:
        //  æ–¹æ³•ä¸€:
        //  PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
        //    -- è·å–PreparedStatementå¯¹è±¡æ—¶,å¦‚æœæˆ‘ä»¬æŠŠautoGeneratedKeyså‚æ•°è®¾ç½®ä¸º1,PreparedStatementçš„getGeneratedKeys()æ–¹æ³•è¿”å›çš„æ˜¯æœ¬æ¬¡PreparedStatementè¯­å¥æ‰§è¡Œæ—¶åˆ›å»ºçš„ä¸»é”®ä¿¡æ¯.
        //  æ–¹æ³•äºŒ:
        //  PreparedStatement prepareStatement(String sql, String columnNames[])
        //    -- è·å–PreparedStatementå¯¹è±¡æ—¶,PreparedStatementçš„getGeneratedKeys()æ–¹æ³•è¿”å›çš„columnNameså‚æ•°æŒ‡å®šçš„æ•°æ®åˆ—çš„æ•°æ®ä¿¡æ¯

        // åœ¨statementTypeå±æ€§çš„å–å€¼ä¸ºPREPAREDæ—¶,å¦‚æœæˆ‘ä»¬é…ç½®äº†keyColumnå±æ€§,é‚£ä¹ˆmybatiså°†ä¼šé€šè¿‡æ–¹æ³•äºŒæ¥åˆ›å»ºPreparedStatementå¯¹è±¡.

        // 1. è¿™é‡Œä¼šè‡ªåŠ¨è¿”å›ç”Ÿæˆä¸»é”®ä¿¡æ¯
        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
      } else {
        // 2. å¦‚æœæœ‰æŒ‡å®šéœ€è¦è¿”å›å“ªäº›åˆ—çš„ä¿¡æ¯,å¯ä»¥åœ¨insert/updateæ ‡ç­¾ä¸­æ‰§è¡ŒkeyColumnNames
        return connection.prepareStatement(sql, keyColumnNames);
      }
    } else if (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) {
      // å¦‚æœResultSetçš„å¤„ç†ç±»å‹æŒ‡å®šä¸º Default ç›´æ¥æ ¹æ®sqlåˆ›å»ºå³å¯
      return connection.prepareStatement(sql);
    } else {
      // ä½¿ç”¨MapperStatementæŒ‡å®šçš„ResultSetTypeå€¼
      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
    }
  }

  @Override
  public void parameterize(Statement statement) throws SQLException {
    parameterHandler.setParameters((PreparedStatement) statement);
  }

}
